## Зачем и как писать тесты?

Какую главную задачу должны решать тесты? Этот вопрос невероятно важен. Ответ на него даёт понимание того, как правильно писать тесты и как писать их не нужно.

Представьте, что вы написали функцию `capitalize(text)`, которая делает заглавной первую букву переданной строки:

```capitalize('hello'); // 'Hello'```

Вот один из вариантов её реализации:

```
const capitalize = (text) => {
const firstChar = text[0].toUpperCase();
const restSubstring = text.slice(1);
return `${firstChar}${restSubstring}`;
};
```
Что мы делаем после создания функции? Проверяем, как она работает. Например, открываем REPL и вызываем функцию с разными аргументами:
```
node
Welcome to Node.js v12.4.0.
> capitalize('hello')
'Hello'
> capitalize('how are you')
> 'How are you'
```
Таким нехитрым способом убеждаемся, что функция работает. По крайней мере для тех аргументов, которые мы передали в неё. Если во время проверки заметили ошибки, то исправляем функцию и повторяем всё заново.

Фактически, весь этот процесс и есть тестирование. Но не автоматическое, а ручное. Задача такого тестирования — убедиться, что код работает как надо. И нам совершенно без разницы, как конкретно реализована эта функция. Это и есть главный ответ на вопрос, заданный в начале урока.

> Тесты проверяют, что код (или приложение) работает корректно. И не заботятся о том, как конкретно написан код, который они проверяют.

Автоматические тесты
Всё, что требуется от автоматических тестов — повторить проверки, которые мы выполняли, делая ручное тестирование. Для этого достаточно старого доброго if и исключений.

Даже если вы не знакомы с исключениями, ничего страшного. В этом курсе достаточно знать две вещи: для чего они нам нужны и какой у них синтаксис. До сих пор в курсах Хекслета вы встречались с ошибками, которые возникают непроизвольно: вызов несуществующей функции, обращение к несуществующей константе и так далее. Но ошибки можно порождать самостоятельно с помощью исключений, что необходимо для нашей ситуации. Исключения создаются такой конструкцией:
```
// Дословно: выбросить новую ошибку
// Исключения бросают
throw new Error('описание исключения');
// Код, следующий за этим выражением, не выполнится, а сам скрипт завершится с ошибкой
console.log('nothing');
```
Пример теста:
```
if (capitalize('hello') !== 'Hello') { // Если результат функции не равен ожидаемому значению
// Выбрасываем исключение и завершаем выполнение теста
throw new Error('Функция работает неверно!');
}
```
Из примера выше видно, что тесты — это точно такой же код, как и любой другой. Он работает в том же окружении и подчиняется тем же правилам, например, стандартам кодирования. А ещё он может содержать ошибки. Но это не значит, что надо писать тесты на тесты. Избежать всех ошибок невозможно, да и не нужно, иначе стоимость разработки стала бы неоправданно высокой. Обнаруженные ошибки в тестах исправляются, и жизнь продолжается дальше ;)

В коде тесты, как правило, складывают в специальную директорию в корне проекта. Обычно она называется tests, хотя встречаются и другие варианты:
```
src/
├── bin
│   └── hexlet.js
├── half.js
└── index.js
tests/
└── half.test.js
```
Структура этой директории зависит от того, на базе чего пишутся тесты, например, на базе какого фреймворка. В простых случаях, она отражает структуру исходного кода. Если предположить, что наша функция `capitalize(text)` определена в файле `src/capitalize.js`, то её тест лучше поместить в файл `tests/capitalize.test.js`. Слово test в имени модуля с тестами, используется только для более явного обозначения цели файла.

Теперь при любых изменениях, затрагивающих эту функцию, важно не забывать запускать тесты:
```
node tests/capitalize.test.js
# Если все хорошо, код молча выполнится.
# Если есть ошибка, то будет выведено сообщение об ошибке.
```
## Как пишутся тесты
Тесты — это не магия. Нам, как разработчикам, нужно самостоятельно импортировать тестируемые функции, вызывать их с необходимыми аргументами и проверять, что функции возвращают ожидаемые значения.

Если поменялась сигнатура функции (входные или выходные параметры, её имя), то придётся переписывать тесты. Если сигнатура осталась той же, но поменялись внутренности функции:
```
const capitalize = (text) => {
const [firstChar, ...restChars] = text;
return `${firstChar.toUpperCase()}${restChars.join('')}`;
};
```
Тогда тесты должны продолжать работать без изменений.

Хорошие тесты ничего не знают про внутреннее устройство проверяемого кода. Это делает их более универсальными и надёжными.

## Сколько и какие нужно писать проверки?
Невозможно написать тесты, которые гарантируют 100% работоспособность кода. Для этого потребовалось бы реализовать проверки всех возможных аргументов, что физически неосуществимо. С другой стороны, без тестов вообще нет никаких гарантий, только честное слово разработчиков.

При написании тестов нужно ориентироваться на разнообразие входных данных. У любой функции есть один или несколько основных сценариев использования. Например, в случае `capitalize()` — это любое слово. Достаточно написать ровно одну проверку, которая покрывает этот сценарий. Дальше нужно смотреть на "пограничные случаи". Это ситуации, в которых код может повести себя по-особенному:

- Работа с пустой строкой
- Обработка `null`
- Деление на ноль (в большинстве языков вызывает ошибку)
- Специфические ситуации для конкретных алгоритмов

Для `capitalize()` пограничным случаем будет пустая строка:
```
if (capitalize('') !== '') {
throw new Error('Функция работает неверно!');
}
```
Добавив тест на пустую строку, мы увидим, что вызов показанной в начале урока функции capitalize() завершается с ошибкой. Внутри неё идёт обращение к первому индексу строки без проверки его существования. Исправленная версия кода:
```
const capitalize = (text) => {
if (text === '') {
return '';
}
const firstChar = text[0].toUpperCase();
const restSubstring = text.slice(1);
return `${firstChar}${restSubstring}`;
};
```
В большом числе ситуаций пограничные случаи требуют отдельной обработки, наличия условных конструкций. Тесты должны быть построены таким образом, чтобы они затрагивали каждую такую конструкцию. Но не забывайте, что условные конструкции могут порождать хитрые связи. Например, два независимых условных блока порождают 4 возможных сценария:

- Функция выполнилась так, что не был выполнен ни один условный блок
- Функция выполнилась так, что был выполнен только первый условный блок
- Функция выполнилась так, что был выполнен только второй условный блок
- Функция выполнилась так, что были выполнены оба условных блока

Комбинация всех возможных вариантов поведения функции называется цикломатической сложностью. Это число показывает все возможные пути кода внутри функции. Цикломатическая сложность — хороший ориентир для понимания того, сколько и какие тесты нужно написать.

Иногда пограничные случаи не связаны с условными конструкциями. Особенно часто такие ситуации встречаются там, где есть вычисления границ слов или массивов. Такой код может работать в большинстве ситуаций, но только в некоторых может давать сбой:
``` 
// В этой функции забыли отнять единицу от длины
// Этот код сработает в некоторых ситуациях, когда последний элемент undefined или в массиве нет элементов
// Но в остальных случаях вернёт неверное значение
const last = (elements) => elements[elements.length];
```

## Проверка входных данных
Особняком стоят ошибки типов входных данных. Например, в функцию `capitalize()` можно передать число вместо строки. Как она должна себя вести в таком случае? Нужно ли писать такой тест?

Ещё один интересный вопрос. Нужно ли внутри capitalize() обрабатывать такие ситуации? Ответ — не нужно. Иначе код превратится в мусорку, а пользы от этого мало. Всё равно должны быть тесты, которые проверяют, что система работает в целом, а они обычно выявляют проблемы кода на более нижних уровнях.

Ответственность за передачу правильных данных в функцию `capitalize()` лежит не на ней, а на коде, который вызывает эту функцию. И если он хорошо протестирован, то подобная ошибка либо обнаружится, либо вообще не возникнет.

Но даже если ошибка обрабатывается внутри функции, не надо пытаться написать тесты, покрывающие каждую ошибку. Это выливается в огромное число тестов, которые требуют поддержки и времени на написание. Нужно уметь вовремя остановиться и двигаться дальше, к покрытию другого кода.

## Собирая всё вместе
В конечном итоге мы получили такую структуру директорий:
```
src/
└── capitalize.js
tests/
└── capitalize.test.js
```
Содержимое теста:
```
if (capitalize('hello') !== 'Hello') {
throw new Error('Функция работает неверно!');
}

if (capitalize('') !== '') {
throw new Error('Функция работает неверно!');
}

console.log('Все тесты пройдены!');
```
Запуск:
```
node tests/capitalize.test.js
```
https://repl.it/@hexlet/js-testing-goal-capitalize#tests/capitalize.test.js

Если всё написано правильно, то запуск тестов завершится с выводом строки Все тесты пройдены! Если в тестах или в коде есть ошибка, то сработает исключение и мы увидим сообщение, указывающее на это.

## Самостоятельная работа
1. Воспроизведите структуру получившуюся в конце урока
2. Запустите тесты, убедитесь что они работают. Попробуйте их сломать
3. Добавьте код на гитхаб
