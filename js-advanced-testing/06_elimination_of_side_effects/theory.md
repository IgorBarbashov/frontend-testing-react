## Инверсия зависимостей
Далеко не всегда результат работы функции связан с побочным эффектом, как это было в предыдущем уроке. Иногда побочный эффект это просто дополнительное действие, которое скорее мешает протестировать основную логику.

Представьте себе функцию, которая регистрирует пользователя. Она создаёт запись в базе данных и отправляет приветственное письмо:
```javascript
const params = {
    email: 'lala@example.com',
    password: 'qwerty',
};
registerUser(params);
```
Эта функция делает много всего, но главное, что нас волнует – правильная регистрация пользователя. Типичная регистрация сводится к добавлению в базу данных записи о новом пользователе. Именно это и нужно проверять – наличие новой записи в базе данных с правильно заполненными данными. А вот возврат функции нам никак не поможет.

Как правило, базу данных в тестах не прячут. В веб-фреймворках она доступна в тестовой среде и работает как обычно. Идемпотентность в ней достигается за счёт транзакций. Перед тестом транзакция начинается и после теста откатывается. Благодаря этому, каждый тест запускается в идентичном окружении и не важно как он его меняет:
```javascript
// Гипотетический пример
const ctx = /* connect to db */;
beforeEach(() => ctx.beginTransaction());

test('registerUser', () => {
    // Внутри идет добавление данных в базу
    const id = registerUser({ name: 'Mike' });
    const user = User.find(id);
    expect(user).toHaveProperty('name', 'Mike');
})

// За счет отката база возвращается в исходное состояние
afterEach(() => ctx.rollbackTransaction());
```
А вот с отправкой писем всё сложнее. Её точно делать нельзя, но как этого добиться? Посмотрите на то, как примерно может выглядеть функция регистрации пользователя:
```javascript
import sendEmail from './emailSender.js';
const registerUser = (params) => {
    const user = new User(params);
    if (user.save()) {
        sendEmail('registration', { user });
        return true;
    }
    return false;
}
```
Существует несколько подходов, позволяющих отключить отправку в тестах. Самый простой — переменная окружения, которая показывает среду выполнения:
```javascript
// Выполняем этот код только если мы не в тестовой среде
if (process.env.NODE_ENV !== 'test') {
    sendEmail('registration', { user });
}
```
Несмотря на простоту использования, такой подход считается плохой практикой. Формально, из-за него происходит нарушение абстракции, код начинает знать о том, где он выполняется. Со временем таких проверок становится всё больше и код становится грязнее. Более того, если нам всё же надо убедиться, что письмо отправляется (с правильными данными!), то мы не сможем этого сделать.

Следующий способ – поддержка режима тестирования внутри самой библиотеки. Например, где-нибудь на этапе инициализации тестов можно сделать так:
```javascript
// setup.js в jest
import sendEmail from './emailSender.js';

// У этого подхода много разновидностей, начиная от установки флага,
// заканчивая заменой функций в прототипе.
sendEmail.test = true;
```
Теперь в любом другом месте, где импортируется и используется функция `sendEmail()`, реальная отправка происходить не будет:
```javascript
// Ничего не происходит
sendEmail('registration', { user });
// В отличие от первого варианта, прикладной код ни о чем не догадывается
```
Это довольно популярное решение. Обычно информация о том, как правильно включить режим тестирования, находится в официальной документации конкретной библиотеки.

Что делать, если используемая библиотека не поддерживает режим тестирования? Существует ещё один, наиболее универсальный способ. Он основан на применении инверсии зависимостей. Программу можно изменить так, чтобы она вызывала функцию `sendEmail()` не напрямую, а принимала её как параметр:
```javascript
import sendEmail from './emailSender.js';

// Ставим значение по умолчанию, чтобы не пришлось постоянно указывать функцию
const registerUser = (params, send = sendEmail) => {
    const user = new User(params);
    if (user.save()) {
        send('registration', { user });
        return true;
    }
    return false;
}
```
И тест:
```javascript
const fakeSendEmail = (...args) => {
    /* Например, письмо можно вывести в терминал для удобства отладки */
};

test('registerUser', () => {
    const id = registerUser({ name: 'Mike' }, fakeSendEmail);
    const user = User.find(id);
    expect(user).toHaveProperty('name', 'Mike');
});
```
Такой способ сложнее в реализации, особенно если функция находится глубоко в стеке вызовов. Это значит, что придётся прокидывать нужные зависимости через всю цепочку функций сверху вниз. Самих зависимостей может быть много, и чем больше используется инверсия, тем сложнее код. За гибкость приходится платить.

Теперь плюсы. Ни библиотека, ни код ничего не знают про тесты. Этот способ наиболее гибкий, он позволяет задавать конкретное поведение для конкретной ситуации. В некоторых экосистемах инверсия зависимостей определяет процесс сборки приложения. Особенно в мире PHP, Java и C#.

## Дополнительные материалы
- [Инверсия зависимостей](https://zen.yandex.ru/media/hexlet/vnedrenie-zavisimostei-chto-eto-takoe-i-kak-rabotaet-5d5684d1a06eaf00ac3ad8cd)
